import { createAsyncThunk, createSlice, nanoid, createSelector, createEntityAdapter } from '@reduxjs/toolkit'
import { client } from '../../api/client';

// const initialState = {
//   posts: [],
//   status: 'idle',
//   error: null
// };
//createEntityAdapter() standardized way to store data in a slice by taking a collection of items
//and putting them into the shape of { ids: [], entities: {} } --> aka the normalization
const postsAdapter = createEntityAdapter({
  // sort newer items to the front based on the post.date field
  sortComparer: (a, b) => b.date.localeCompare(a.date)
});

//getInitialState() returns an empty {ids: [], entities: {}} normalized state object
const initialState = postsAdapter.getInitialState({
  // pass additional fields to the empty object
  status: 'idle',
  error: null
});

//'posts/fetchPosts' will be used as the prefix for the generated action types
// callback function that should return a Promise containing some data, or a rejected Promise with an error
export const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {
  const response = await client.get('/fakeApi/posts');
  return response.data; 
});
// createAsyncThunk API generates thunks 
// that automatically dispatch those "start/success/failure" actions for you.
export const addNewPost = createAsyncThunk(
  'posts/addNewPost',
  //the payload creator receives the partial `{title, content, user}` object
  async initialPost => {
    // send the initial data to the fake API server
    const response = await client.post('/fakeApi/posts', initialPost)
    // response includes the complete post object, including unique ID
    return response.data
  }
);

//the action creators generated by createSlice 
const postsSlice = createSlice({
  name: 'posts',
  initialState,
  reducers: {
      postAdded: {
        reducer(state, action) {
            state.posts.push(action.payload);
        },
        // "prepare callback" function can take multiple arguments, 
        // generate random values like unique IDs, and run whatever other synchronous logic is needed to decide what values go into the action object. 
        // It should then return an object with the payload field inside.
        prepare(title, content, userId) {
            return {
              payload: {
                id: nanoid(),
                title,
                content,
                user: userId,
                date: new Date().toISOString(),
                reactions: {
                  thumbsUp: 0,
                  hooray: 0,
                  heart: 0,
                  rocket: 0,
                  eyes: 0,
                }
              }
            }
        }
      },
      postUpdated(state, action) {
        const { postId, title, content } = action.payload;
        // const existingPost = state.posts.find(post => post.id === id);
        
        // posts are kept as a lookup table in state.entities so directly look up by id
        const existingPost = state.entities[postId];
        if (existingPost) {
          existingPost.title = title;
          existingPost.content = content;
        }
      },
      reactionAdded(state, action) {
        const { postId, reaction } = action.payload;
        //const existingPost = state.posts.find(post => post.id === postId);
        const existingPost = state.entities[postId];
        if (existingPost) {
          existingPost.reactions[reaction]++;
        }
      }
  },
  //when a slice reducer needs to respond to other actions that weren't defined 
  // as part of this slice's reducers field. Use the slice extraReducers
  extraReducers(builder) {
    builder //provides methods that let us define additional case reducers that will run in response to actions defined outside of the slice
      .addCase(fetchPosts.pending, (state, action) => {
        state.status = 'loading';
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.status = 'succeeded';
        // Add any fetched posts to the array
        //state.posts = state.posts.concat(action.payload);
        //upsertMany() reducer is a mutating update utility. add all of the incoming posts to the state
        postsAdapter.upsertMany(state, action.payload);
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message;
      })
      .addCase(addNewPost.fulfilled, postsAdapter.addOne); //addOne() is reducer for the fulfilled case
      // .addCase(addNewPost.fulfilled, (state, action) => {
      //   // we can directly add the new post object to our posts array
      //   state.posts.push(action.payload);
      // })
  }

})

// export the action creator function that createSlice generated so that the UI can dispatch these
export const { postAdded, postUpdated, reactionAdded } = postsSlice.actions;

export default postsSlice.reducer;

/*
use postsAdapter.getSelectors() instead
export const selectAllPosts = state => state.posts.posts;
export const selectPostById = (state, postId) => 
  state.posts.posts.find(post => post.id === postId);
*/
// export the customized selectors for this adapter using `getSelectors`
export const {
  selectAll: selectAllPosts, //rename as we export them and match the old selector names
  selectById: selectPostById,
  selectIds: selectPostIds
  // pass in a selector that returns the posts slice of state
} = postsAdapter.getSelectors(state => state.posts);

//createSelector() generates memoized selectors that will only recalculate results when the inputs change
//createSelector() will pass all of the arguments into each of our input selectors
//and what those input selectors return becomes the arguments for the output selector
//it will only re-run the output selector if either posts or userId has changed
export const selectPostsByUser = createSelector (
  [selectAllPosts, (state, userId) => userId], //input selector
  (posts, userId) => posts.filter(post => post.user === userId) //output selector
);