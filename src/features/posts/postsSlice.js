import { createAsyncThunk, createSlice, nanoid } from '@reduxjs/toolkit'
import { client } from '../../api/client';

const initialState = {
  posts: [],
  status: 'idle',
  error: null
};

//'posts/fetchPosts' will be used as the prefix for the generated action types
// callback function that should return a Promise containing some data, or a rejected Promise with an error
export const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {
  const response = await client.get('/fakeApi/posts');
  return response.data; 
});
// createAsyncThunk API generates thunks 
// that automatically dispatch those "start/success/failure" actions for you.
export const addNewPost = createAsyncThunk(
  'posts/addNewPost',
  //the payload creator receives the partial `{title, content, user}` object
  async initialPost => {
    // send the initial data to the fake API server
    const response = await client.post('/fakeApi/posts', initialPost)
    // response includes the complete post object, including unique ID
    return response.data
  }
);
//the action creators generated by createSlice 
const postsSlice = createSlice({
  name: 'posts',
  initialState,
  reducers: {
      postAdded: {
        reducer(state, action) {
            state.posts.push(action.payload);
        },
        // "prepare callback" function can take multiple arguments, 
        // generate random values like unique IDs, and run whatever other synchronous logic is needed to decide what values go into the action object. 
        // It should then return an object with the payload field inside.
        prepare(title, content, userId) {
            return {
              payload: {
                id: nanoid(),
                title,
                content,
                user: userId,
                date: new Date().toISOString(),
                reactions: {
                  thumbsUp: 0,
                  hooray: 0,
                  heart: 0,
                  rocket: 0,
                  eyes: 0,
                }
              }
            }
        }
      },
      postUpdated(state, action) {
        const { id, title, content } = action.payload
        const existingPost = state.posts.find(post => post.id === id)
        if (existingPost) {
          existingPost.title = title
          existingPost.content = content
        }
      },
      reactionAdded(state, action) {
        const { postId, reaction } = action.payload
        const existingPost = state.posts.find(post => post.id === postId)
        if (existingPost) {
          existingPost.reactions[reaction]++
        }
      }
  },
  //when a slice reducer needs to respond to other actions that weren't defined 
  // as part of this slice's reducers field. Use the slice extraReducers
  extraReducers(builder) {
    builder //provides methods that let us define additional case reducers that will run in response to actions defined outside of the slice
      .addCase(fetchPosts.pending, (state, action) => {
        state.status = 'loading'
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.status = 'succeeded'
        // Add any fetched posts to the array
        state.posts = state.posts.concat(action.payload)
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.status = 'failed'
        state.error = action.error.message
      })
      .addCase(addNewPost.fulfilled, (state, action) => {
        // we can directly add the new post object to our posts array
        state.posts.push(action.payload)
      })
  }

})

// export the action creator function that createSlice generated so that the UI can dispatch these
export const { postAdded, postUpdated, reactionAdded } = postsSlice.actions;

export default postsSlice.reducer;

export const selectAllPosts = state => state.posts.posts;

export const selectPostById = (state, postId) => 
  state.posts.posts.find(post => post.id === postId);